
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>scattertext.external.phrasemachine.phrasemachine &#8212; Scattertext 0.0.2.9 documentation</title>
    <link rel="stylesheet" href="../../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" src="../../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for scattertext.external.phrasemachine.phrasemachine</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Noun phrase extraction using Python&#39;s regular expression library.</span>
<span class="sd">Only for the &quot;SimpleNP&quot; grammar.</span>



<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">Counter</span>

<span class="c1">#from pkg_resources import resource_filename</span>


<div class="viewcode-block" id="logmsg"><a class="viewcode-back" href="../../../../scattertext.external.phrasemachine.html#scattertext.external.phrasemachine.phrasemachine.logmsg">[docs]</a><span class="k">def</span> <span class="nf">logmsg</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
	<span class="c1"># would be better to use python logger</span>
	<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[phrasemachine] </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">s</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span></div>


<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
	<span class="n">xrange</span> <span class="o">=</span> <span class="nb">range</span>

<span class="c1">############## SimpleNP</span>
<span class="c1">## Uses a five-tag coarse grammar.</span>
<span class="c1">## tagset: A D P N O</span>

<span class="c1"># Requires conversion from PTB or Petrov/Gimpel tags to our system.</span>
<span class="c1"># &quot;Coarse*&quot; indicates petrov/gimpel</span>
<span class="c1"># Grammar change from the FST version: can&#39;t repeat NUM in both adj and noun.</span>
<span class="n">coarsemap</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="s2">&quot;JJ JJR JJS CoarseADJ CD CoarseNUM&quot;</span><span class="o">.</span><span class="n">split</span><span class="p">(),</span>
	<span class="s1">&#39;D&#39;</span><span class="p">:</span> <span class="s2">&quot;DT CoarseDET&quot;</span><span class="o">.</span><span class="n">split</span><span class="p">(),</span>
	<span class="s1">&#39;P&#39;</span><span class="p">:</span> <span class="s2">&quot;IN TO CoarseADP&quot;</span><span class="o">.</span><span class="n">split</span><span class="p">(),</span>
	<span class="s1">&#39;N&#39;</span><span class="p">:</span> <span class="s2">&quot;NN NNS NNP NNPS FW CoarseNOUN&quot;</span><span class="o">.</span><span class="n">split</span><span class="p">(),</span>
	<span class="c1"># all other tags get O</span>
<span class="p">}</span>

<span class="c1">## OLDER ATTEMPT: tried to use direct tags as port from foma.</span>
<span class="c1">## but this was annoying. have to map back to token positions at the end.</span>
<span class="c1">## probably slower too since the python regex compiler is not as smart as foma</span>
<span class="c1"># def regex_or(items):</span>
<span class="c1">#     return &#39;|&#39;.join(re.escape(x) for x in items)</span>
<span class="c1"># Adj = regex_or(&quot;JJ JJR JJS CD CoarseADJ CoarseNUM&quot;.split())</span>
<span class="c1"># Det = regex_or(&quot;DT CoarseDET&quot;.split())</span>
<span class="c1"># Prep= regex_or(&quot;IN TO CoarseADP&quot;.split())</span>
<span class="c1"># Noun= regex_or(&quot;NN NNS NNP NNPS FW CD CoarseNOUN CoarseNUM&quot;.split())</span>
<span class="c1"># ## convention: SPACES separate tags.</span>
<span class="c1"># BaseNP = &quot;(({Adj}|{Noun}) )*({Noun} )+&quot;.format(**globals())</span>
<span class="c1"># PP     = &quot;{Prep} ({Det} )*{BaseNP}&quot;.format(**globals())</span>
<span class="c1"># NP     = &quot;{BaseNP}({PP} )*&quot;.format(**globals())</span>

<span class="n">tag2coarse</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">coarsetag</span><span class="p">,</span> <span class="n">inputtags</span> <span class="ow">in</span> <span class="n">coarsemap</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
	<span class="k">for</span> <span class="n">intag</span> <span class="ow">in</span> <span class="n">inputtags</span><span class="p">:</span>
		<span class="k">assert</span> <span class="n">intag</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">tag2coarse</span>
		<span class="n">tag2coarse</span><span class="p">[</span><span class="n">intag</span><span class="p">]</span> <span class="o">=</span> <span class="n">coarsetag</span>

<span class="c1">## The grammar!</span>
<span class="n">SimpleNP</span> <span class="o">=</span> <span class="s2">&quot;(A|N)*N(PD*(A|N)*N)*&quot;</span>


<div class="viewcode-block" id="coarse_tag_str"><a class="viewcode-back" href="../../../../scattertext.external.phrasemachine.html#scattertext.external.phrasemachine.phrasemachine.coarse_tag_str">[docs]</a><span class="k">def</span> <span class="nf">coarse_tag_str</span><span class="p">(</span><span class="n">pos_seq</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Convert POS sequence to our coarse system, formatted as a string.&quot;&quot;&quot;</span>
	<span class="k">global</span> <span class="n">tag2coarse</span>
	<span class="n">tags</span> <span class="o">=</span> <span class="p">[</span><span class="n">tag2coarse</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="s1">&#39;O&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">pos_seq</span><span class="p">]</span>
	<span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tags</span><span class="p">)</span></div>


<span class="c1"># POS extraction assuming list of POS tags as input.</span>
<span class="c1"># &gt;&gt;&gt; pyre.extract_finditer([&quot;VB&quot;,&quot;JJ&quot;,&quot;NN&quot;,&quot;NN&quot;,&quot;QQ&quot;,&quot;QQ&quot;,])</span>
<span class="c1"># [(1, 4)]</span>
<span class="c1"># &gt;&gt;&gt; pyre.extract_ngram_filter([&quot;VB&quot;,&quot;JJ&quot;,&quot;NN&quot;,&quot;NN&quot;,&quot;QQ&quot;,&quot;QQ&quot;,])</span>
<span class="c1"># [(1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]</span>

<div class="viewcode-block" id="extract_finditer"><a class="viewcode-back" href="../../../../scattertext.external.phrasemachine.html#scattertext.external.phrasemachine.phrasemachine.extract_finditer">[docs]</a><span class="k">def</span> <span class="nf">extract_finditer</span><span class="p">(</span><span class="n">pos_seq</span><span class="p">,</span> <span class="n">regex</span><span class="o">=</span><span class="n">SimpleNP</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;The &quot;GreedyFSA&quot; method in Handler et al. 2016.</span>
<span class="sd">	Returns token position spans of valid ngrams.&quot;&quot;&quot;</span>
	<span class="n">ss</span> <span class="o">=</span> <span class="n">coarse_tag_str</span><span class="p">(</span><span class="n">pos_seq</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">gen</span><span class="p">():</span>
		<span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">re</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span><span class="n">regex</span><span class="p">,</span> <span class="n">ss</span><span class="p">):</span>
			<span class="k">yield</span> <span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">start</span><span class="p">(),</span> <span class="n">m</span><span class="o">.</span><span class="n">end</span><span class="p">())</span>

	<span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">gen</span><span class="p">())</span></div>


<div class="viewcode-block" id="extract_ngram_filter"><a class="viewcode-back" href="../../../../scattertext.external.phrasemachine.html#scattertext.external.phrasemachine.phrasemachine.extract_ngram_filter">[docs]</a><span class="k">def</span> <span class="nf">extract_ngram_filter</span><span class="p">(</span><span class="n">pos_seq</span><span class="p">,</span> <span class="n">regex</span><span class="o">=</span><span class="n">SimpleNP</span><span class="p">,</span> <span class="n">minlen</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">maxlen</span><span class="o">=</span><span class="mi">8</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;The &quot;FilterFSA&quot; method in Handler et al. 2016.</span>
<span class="sd">	Returns token position spans of valid ngrams.&quot;&quot;&quot;</span>
	<span class="n">ss</span> <span class="o">=</span> <span class="n">coarse_tag_str</span><span class="p">(</span><span class="n">pos_seq</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">gen</span><span class="p">():</span>
		<span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ss</span><span class="p">)):</span>
			<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">minlen</span><span class="p">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">min</span><span class="p">(</span><span class="n">maxlen</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ss</span><span class="p">)</span> <span class="o">-</span> <span class="n">s</span><span class="p">)):</span>
				<span class="n">e</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="n">n</span>
				<span class="n">substr</span> <span class="o">=</span> <span class="n">ss</span><span class="p">[</span><span class="n">s</span><span class="p">:</span><span class="n">e</span><span class="p">]</span>
				<span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">regex</span> <span class="o">+</span> <span class="s2">&quot;$&quot;</span><span class="p">,</span> <span class="n">substr</span><span class="p">):</span>
					<span class="k">yield</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>

	<span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">gen</span><span class="p">())</span></div>


<div class="viewcode-block" id="extract_JK"><a class="viewcode-back" href="../../../../scattertext.external.phrasemachine.html#scattertext.external.phrasemachine.phrasemachine.extract_JK">[docs]</a><span class="k">def</span> <span class="nf">extract_JK</span><span class="p">(</span><span class="n">pos_seq</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;The &#39;JK&#39; method in Handler et al. 2016.</span>
<span class="sd">	Returns token positions of valid ngrams.&quot;&quot;&quot;</span>

	<span class="k">def</span> <span class="nf">find_ngrams</span><span class="p">(</span><span class="n">input_list</span><span class="p">,</span> <span class="n">num_</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;get ngrams of len n from input list&#39;&#39;&#39;</span>
		<span class="k">return</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">input_list</span><span class="p">[</span><span class="n">i</span><span class="p">:]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_</span><span class="p">)])</span>

	<span class="c1"># copied from M and S chp 5&#39;&#39;&#39;</span>
	<span class="n">patterns</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="s1">&#39;AN&#39;</span><span class="p">,</span> <span class="s1">&#39;NN&#39;</span><span class="p">,</span> <span class="s1">&#39;AAN&#39;</span><span class="p">,</span> <span class="s1">&#39;ANN&#39;</span><span class="p">,</span> <span class="s1">&#39;NAN&#39;</span><span class="p">,</span> <span class="s1">&#39;NNN&#39;</span><span class="p">,</span> <span class="s1">&#39;NPN&#39;</span><span class="p">])</span>
	<span class="n">pos_seq</span> <span class="o">=</span> <span class="p">[</span><span class="n">tag2coarse</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="s1">&#39;O&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">pos_seq</span><span class="p">]</span>
	<span class="n">pos_seq</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pos_seq</span><span class="p">)]</span>
	<span class="n">ngrams</span> <span class="o">=</span> <span class="p">[</span><span class="n">ngram</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="k">for</span> <span class="n">ngram</span> <span class="ow">in</span> <span class="n">find_ngrams</span><span class="p">(</span><span class="n">pos_seq</span><span class="p">,</span> <span class="n">n</span><span class="p">)]</span>

	<span class="k">def</span> <span class="nf">stringify</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
		<span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">s</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">positionify</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
		<span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">s</span><span class="p">)</span>

	<span class="n">ngrams</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">stringify</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">in</span> <span class="n">patterns</span><span class="p">,</span> <span class="n">ngrams</span><span class="p">)</span>
	<span class="k">return</span> <span class="p">[</span><span class="nb">set</span><span class="p">(</span><span class="n">positionify</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">ngrams</span><span class="p">]</span></div>


<span class="c1">########</span>

<div class="viewcode-block" id="unicodify"><a class="viewcode-back" href="../../../../scattertext.external.phrasemachine.html#scattertext.external.phrasemachine.phrasemachine.unicodify">[docs]</a><span class="k">def</span> <span class="nf">unicodify</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;utf8&#39;</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
	<span class="c1"># Force conversion to unicode</span>
	<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">unicode</span><span class="p">):</span> <span class="k">return</span> <span class="n">s</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span> <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">encoding</span><span class="p">,</span> <span class="n">errors</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">unicode</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="nb">bytes</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf8&#39;</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">s</span></div>


<div class="viewcode-block" id="safejoin"><a class="viewcode-back" href="../../../../scattertext.external.phrasemachine.html#scattertext.external.phrasemachine.phrasemachine.safejoin">[docs]</a><span class="k">def</span> <span class="nf">safejoin</span><span class="p">(</span><span class="n">list_of_str_or_unicode</span><span class="p">):</span>
	<span class="c1">## can accept a list of str objects, or a list of unicodes.</span>
	<span class="c1">## safely joins them, returning the same type.</span>
	<span class="n">xx</span> <span class="o">=</span> <span class="n">list_of_str_or_unicode</span>
	<span class="k">if</span> <span class="ow">not</span> <span class="n">xx</span><span class="p">:</span>
		<span class="k">return</span> <span class="sa">u</span><span class="s2">&quot;&quot;</span>
	<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">xx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
		<span class="k">return</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">xx</span><span class="p">)</span>

	<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">xx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">bytes</span><span class="p">):</span>
		<span class="k">return</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">xx</span><span class="p">)</span>

	<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">xx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">unicode</span><span class="p">):</span>
			<span class="k">return</span> <span class="sa">u</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">xx</span><span class="p">)</span>

	<span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Bad input to safejoin:&quot;</span><span class="p">,</span> <span class="n">list_of_str_or_unicode</span><span class="p">)</span></div>


<span class="c1">#########</span>

<div class="viewcode-block" id="NLTKTagger"><a class="viewcode-back" href="../../../../scattertext.external.phrasemachine.html#scattertext.external.phrasemachine.phrasemachine.NLTKTagger">[docs]</a><span class="k">class</span> <span class="nc">NLTKTagger</span><span class="p">:</span>
	<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">	class that supplies part of speech tags using NLTK</span>
<span class="sd">	note: avoids the NLTK downloader (see __init__ method)</span>
<span class="sd">	&#39;&#39;&#39;</span>

	<span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="kn">import</span> <span class="nn">nltk</span>
		<span class="kn">from</span> <span class="nn">nltk.tag</span> <span class="k">import</span> <span class="n">PerceptronTagger</span>
		<span class="kn">from</span> <span class="nn">nltk.tokenize</span> <span class="k">import</span> <span class="n">TreebankWordTokenizer</span>
		<span class="c1">#return pkgutil.get_data(&#39;scattertext&#39;,</span>
		<span class="c1">#                        &#39;data/viz/semiotic_new.html&#39;).decode(&#39;utf-8&#39;)</span>
		<span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="s1">&#39;scattertext&#39;</span><span class="p">]</span><span class="o">.</span><span class="vm">__file__</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;/data/&#39;</span>
		<span class="n">tokenizer_fn</span> <span class="o">=</span> <span class="n">path</span> <span class="o">+</span> <span class="s1">&#39;punkt.english.pickle&#39;</span>
		<span class="n">tagger_fn</span> <span class="o">=</span> <span class="n">path</span> <span class="o">+</span> <span class="s1">&#39;averaged_perceptron_tagger.pickle&#39;</span>
		<span class="c1">#tokenizer_fn = os.path.abspath(resource_filename(&#39;scattertext.data&#39;, &#39;punkt.english.pickle&#39;))</span>
		<span class="c1">#tagger_fn = os.path.abspath(resource_filename(&#39;scattertext.data&#39;, &#39;averaged_perceptron_tagger.pickle&#39;))</span>
		<span class="c1"># Load the tagger</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">tagger</span> <span class="o">=</span> <span class="n">PerceptronTagger</span><span class="p">(</span><span class="n">load</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">tagger</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">tagger_fn</span><span class="p">)</span>

		<span class="c1"># note: nltk.word_tokenize calls the TreebankWordTokenizer, but uses the downloader.</span>
		<span class="c1">#       Calling the TreebankWordTokenizer like this allows skipping the downloader.</span>
		<span class="c1">#       It seems the TreebankWordTokenizer uses PTB tokenization = regexes. i.e. no downloads</span>
		<span class="c1">#       https://github.com/nltk/nltk/blob/develop/nltk/tokenize/treebank.py#L25</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">tokenize</span> <span class="o">=</span> <span class="n">TreebankWordTokenizer</span><span class="p">()</span><span class="o">.</span><span class="n">tokenize</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">sent_detector</span> <span class="o">=</span> <span class="n">nltk</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">tokenizer_fn</span><span class="p">)</span>

	<span class="c1"># http://www.nltk.org/book/ch05.html</span>
<div class="viewcode-block" id="NLTKTagger.tag_text"><a class="viewcode-back" href="../../../../scattertext.external.phrasemachine.html#scattertext.external.phrasemachine.phrasemachine.NLTKTagger.tag_text">[docs]</a>	<span class="k">def</span> <span class="nf">tag_text</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;take input text and return tokens w/ part of speech tags using NLTK&#39;&#39;&#39;</span>
		<span class="c1"># putting import here instead of top of file b.c. not all will have nltk installed</span>

		<span class="n">sents</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sent_detector</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>  <span class="c1"># TODO: this will fail on some unicode chars. I think assumes ascii</span>
		<span class="n">word_pos_pairs</span> <span class="o">=</span> <span class="p">[]</span>

		<span class="n">all_tokens</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">for</span> <span class="n">sent</span> <span class="ow">in</span> <span class="n">sents</span><span class="p">:</span>
			<span class="n">tokens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="n">sent</span><span class="p">)</span>
			<span class="n">all_tokens</span> <span class="o">=</span> <span class="n">all_tokens</span> <span class="o">+</span> <span class="n">tokens</span>
			<span class="n">word_pos_pairs</span> <span class="o">=</span> <span class="n">word_pos_pairs</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">tagger</span><span class="o">.</span><span class="n">tag</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">{</span><span class="s1">&#39;tokens&#39;</span><span class="p">:</span> <span class="n">all_tokens</span><span class="p">,</span> <span class="s1">&#39;pos&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">tag</span> <span class="k">for</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">tag</span><span class="p">)</span> <span class="ow">in</span> <span class="n">word_pos_pairs</span><span class="p">]}</span></div>

<div class="viewcode-block" id="NLTKTagger.tag_tokens"><a class="viewcode-back" href="../../../../scattertext.external.phrasemachine.html#scattertext.external.phrasemachine.phrasemachine.NLTKTagger.tag_tokens">[docs]</a>	<span class="k">def</span> <span class="nf">tag_tokens</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokens</span><span class="p">):</span>
		<span class="n">word_pos_pairs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tagger</span><span class="o">.</span><span class="n">tag</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">{</span><span class="s1">&#39;tokens&#39;</span><span class="p">:</span> <span class="n">tokens</span><span class="p">,</span> <span class="s1">&#39;pos&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">tag</span> <span class="k">for</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">tag</span><span class="p">)</span> <span class="ow">in</span> <span class="n">word_pos_pairs</span><span class="p">]}</span></div></div>


<div class="viewcode-block" id="get_stdeng_nltk_tagger"><a class="viewcode-back" href="../../../../scattertext.external.phrasemachine.html#scattertext.external.phrasemachine.phrasemachine.get_stdeng_nltk_tagger">[docs]</a><span class="k">def</span> <span class="nf">get_stdeng_nltk_tagger</span><span class="p">(</span><span class="n">suppress_errors</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
	<span class="k">try</span><span class="p">:</span>
		<span class="n">tagger</span> <span class="o">=</span> <span class="n">NLTKTagger</span><span class="p">()</span>
		<span class="n">throw_away</span> <span class="o">=</span> <span class="n">tagger</span><span class="o">.</span><span class="n">tag_text</span><span class="p">(</span><span class="s2">&quot;The red cat sat down.&quot;</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NLTKTagger</span><span class="p">()</span>
	<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">suppress_errors</span><span class="p">:</span> <span class="k">raise</span>
	<span class="k">except</span> <span class="ne">LookupError</span><span class="p">:</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">suppress_errors</span><span class="p">:</span> <span class="k">raise</span>
	<span class="k">return</span> <span class="kc">None</span></div>


<span class="n">SPACY_WRAPPER</span> <span class="o">=</span> <span class="kc">None</span>


<div class="viewcode-block" id="SpacyTagger"><a class="viewcode-back" href="../../../../scattertext.external.phrasemachine.html#scattertext.external.phrasemachine.phrasemachine.SpacyTagger">[docs]</a><span class="k">class</span> <span class="nc">SpacyTagger</span><span class="p">:</span>
	<span class="c1"># https://spacy.io/</span>
	<span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">spacy_object</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="SpacyTagger.tag_text"><a class="viewcode-back" href="../../../../scattertext.external.phrasemachine.html#scattertext.external.phrasemachine.phrasemachine.SpacyTagger.tag_text">[docs]</a>	<span class="k">def</span> <span class="nf">tag_text</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
		<span class="n">text</span> <span class="o">=</span> <span class="n">unicodify</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
		<span class="n">doc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spacy_object</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">{</span>
			<span class="s1">&#39;pos&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">token</span><span class="o">.</span><span class="n">tag_</span> <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">doc</span><span class="p">],</span>
			<span class="s1">&#39;tokens&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">token</span><span class="o">.</span><span class="n">text</span> <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">doc</span><span class="p">],</span>
		<span class="p">}</span></div>

<div class="viewcode-block" id="SpacyTagger.tag_tokens"><a class="viewcode-back" href="../../../../scattertext.external.phrasemachine.html#scattertext.external.phrasemachine.phrasemachine.SpacyTagger.tag_tokens">[docs]</a>	<span class="k">def</span> <span class="nf">tag_tokens</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokens</span><span class="p">):</span>
		<span class="c1"># tokens: a list of strings</span>
		<span class="c1"># todo: would be better to force spacy to use the given tokenization</span>
		<span class="n">newtext</span> <span class="o">=</span> <span class="n">safejoin</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
		<span class="n">newtext</span> <span class="o">=</span> <span class="n">unicodify</span><span class="p">(</span><span class="n">newtext</span><span class="p">)</span>  <span class="c1">## spacy wants unicode objects only. problem if user gave us a string.</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tag_text</span><span class="p">(</span><span class="n">newtext</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="get_stdeng_spacy_tagger"><a class="viewcode-back" href="../../../../scattertext.external.phrasemachine.html#scattertext.external.phrasemachine.phrasemachine.get_stdeng_spacy_tagger">[docs]</a><span class="k">def</span> <span class="nf">get_stdeng_spacy_tagger</span><span class="p">(</span><span class="n">suppress_errors</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
	<span class="k">global</span> <span class="n">SPACY_WRAPPER</span>
	<span class="k">if</span> <span class="n">SPACY_WRAPPER</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
		<span class="k">return</span> <span class="n">SPACY_WRAPPER</span>
	<span class="k">try</span><span class="p">:</span>
		<span class="kn">import</span> <span class="nn">spacy</span>
		<span class="n">SPACY_WRAPPER</span> <span class="o">=</span> <span class="n">SpacyTagger</span><span class="p">()</span>
		<span class="n">SPACY_WRAPPER</span><span class="o">.</span><span class="n">spacy_object</span> <span class="o">=</span> <span class="n">spacy</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;en&#39;</span><span class="p">,</span> <span class="n">parser</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">entity</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">SPACY_WRAPPER</span>
	<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">suppress_errors</span><span class="p">:</span> <span class="k">raise</span>
	<span class="k">except</span> <span class="ne">RuntimeError</span><span class="p">:</span>
		<span class="c1">## this seems to happen if the &#39;en&#39; model is not installed. it might</span>
		<span class="c1">## look like this:</span>
		<span class="c1"># RuntimeError: Model &#39;en&#39; not installed. Please run &#39;python -m spacy.en.download&#39; to install latest compatible model.</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">suppress_errors</span><span class="p">:</span> <span class="k">raise</span>
	<span class="k">return</span> <span class="kc">None</span></div>


<span class="n">TAGGER_NAMES</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s1">&#39;nltk&#39;</span><span class="p">:</span> <span class="n">get_stdeng_nltk_tagger</span><span class="p">,</span>
	<span class="s1">&#39;spacy&#39;</span><span class="p">:</span> <span class="n">get_stdeng_spacy_tagger</span><span class="p">,</span>
	<span class="c1"># &#39;twitter&#39;: None,</span>
<span class="p">}</span>


<div class="viewcode-block" id="get_phrases"><a class="viewcode-back" href="../../../../scattertext.external.phrasemachine.html#scattertext.external.phrasemachine.phrasemachine.get_phrases">[docs]</a><span class="k">def</span> <span class="nf">get_phrases</span><span class="p">(</span><span class="n">text</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tokens</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">postags</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tagger</span><span class="o">=</span><span class="s1">&#39;nltk&#39;</span><span class="p">,</span> <span class="n">grammar</span><span class="o">=</span><span class="s1">&#39;SimpleNP&#39;</span><span class="p">,</span> <span class="n">regex</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">minlen</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">maxlen</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span>
                <span class="n">output</span><span class="o">=</span><span class="s1">&#39;counts&#39;</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Give a text (or POS tag sequence), return the phrases matching the given</span>
<span class="sd">	grammar.  Works on documents or sentences.</span>
<span class="sd">	Returns a dict with one or more keys with the phrase information.</span>

<span class="sd">	text: the text of the document.  If supplied, we will try to POS tag it.</span>

<span class="sd">	You can also do your own tokenzation and/or tagging and supply them as</span>
<span class="sd">	&#39;tokens&#39; and/or &#39;postags&#39;, which are lists of strings (of the same length).</span>
<span class="sd">	 - Must supply both to get phrase counts back.</span>
<span class="sd">	 - With only postags, can get phrase token spans back.</span>
<span class="sd">	 - With only tokens, we will try to POS-tag them if possible.</span>

<span class="sd">	output: a string, or list of strings, of information to return. Options include:</span>
<span class="sd">	 - counts: a Counter with phrase frequencies.  (default)</span>
<span class="sd">	 - token_spans: a list of the token spans of each matched phrase.  This is</span>
<span class="sd">		 a list of (start,end) pairs of integers, which refer to token positions.</span>
<span class="sd">	 - pos, tokens can be returned too.</span>

<span class="sd">	tagger: if you&#39;re passing in raw text, can supply your own tagger, from one</span>
<span class="sd">	of the get_*_tagger() functions.  If this is not supplied, we will try to load one.</span>

<span class="sd">	grammar: the grammar to use.  Only one option right now...</span>

<span class="sd">	regex: a custom regex to use, instead of a premade grammar.  Currently,</span>
<span class="sd">	this must work on the 5-tag system described near the top of this file.</span>

<span class="sd">	&quot;&quot;&quot;</span>
	<span class="k">global</span> <span class="n">SimpleNP</span>

	<span class="c1">## try to get values for both &#39;postags&#39; and &#39;tokens&#39;, parallel lists of strings</span>
	<span class="k">if</span> <span class="n">postags</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
		<span class="k">try</span><span class="p">:</span>
			<span class="n">tagger</span> <span class="o">=</span> <span class="n">TAGGER_NAMES</span><span class="p">[</span><span class="n">tagger</span><span class="p">]()</span>
		<span class="k">except</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;We don&#39;t support tagger </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">tagger</span><span class="p">)</span>
		<span class="c1"># otherwise, assume it&#39;s one of our wrapper *Tagger objects</span>

		<span class="n">d</span> <span class="o">=</span> <span class="kc">None</span>
		<span class="k">if</span> <span class="n">tokens</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">d</span> <span class="o">=</span> <span class="n">tagger</span><span class="o">.</span><span class="n">tag_tokens</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
		<span class="k">elif</span> <span class="n">text</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">d</span> <span class="o">=</span> <span class="n">tagger</span><span class="o">.</span><span class="n">tag_text</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Need to supply text or tokens.&quot;</span><span class="p">)</span>
		<span class="n">postags</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;pos&#39;</span><span class="p">]</span>
		<span class="n">tokens</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;tokens&#39;</span><span class="p">]</span>

	<span class="k">if</span> <span class="n">regex</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
		<span class="k">if</span> <span class="n">grammar</span> <span class="o">==</span> <span class="s1">&#39;SimpleNP&#39;</span><span class="p">:</span>
			<span class="n">regex</span> <span class="o">=</span> <span class="n">SimpleNP</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;Don&#39;t know grammar </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">grammar</span>

	<span class="n">phrase_tokspans</span> <span class="o">=</span> <span class="n">extract_ngram_filter</span><span class="p">(</span><span class="n">postags</span><span class="p">,</span> <span class="n">minlen</span><span class="o">=</span><span class="n">minlen</span><span class="p">,</span> <span class="n">maxlen</span><span class="o">=</span><span class="n">maxlen</span><span class="p">)</span>

	<span class="c1">## Handle multiple possible return info outputs</span>

	<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
		<span class="n">output</span> <span class="o">=</span> <span class="p">[</span><span class="n">output</span><span class="p">]</span>

	<span class="n">our_options</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

	<span class="k">def</span> <span class="nf">retopt</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
		<span class="n">our_options</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">output</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="p">{}</span>
	<span class="n">ret</span><span class="p">[</span><span class="s1">&#39;num_tokens&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">postags</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">retopt</span><span class="p">(</span><span class="s1">&#39;token_spans&#39;</span><span class="p">):</span>
		<span class="n">ret</span><span class="p">[</span><span class="s1">&#39;token_spans&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">phrase_tokspans</span>
	<span class="k">if</span> <span class="n">retopt</span><span class="p">(</span><span class="s1">&#39;counts&#39;</span><span class="p">):</span>
		<span class="n">counts</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">()</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span> <span class="ow">in</span> <span class="n">phrase_tokspans</span><span class="p">:</span>
			<span class="n">phrase</span> <span class="o">=</span> <span class="n">safejoin</span><span class="p">([</span><span class="n">tokens</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)])</span>
			<span class="n">phrase</span> <span class="o">=</span> <span class="n">phrase</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
			<span class="n">counts</span><span class="p">[</span><span class="n">phrase</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
		<span class="n">ret</span><span class="p">[</span><span class="s1">&#39;counts&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">counts</span>
	<span class="k">if</span> <span class="n">retopt</span><span class="p">(</span><span class="s1">&#39;pos&#39;</span><span class="p">):</span>
		<span class="n">ret</span><span class="p">[</span><span class="s1">&#39;pos&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">postags</span>
	<span class="k">if</span> <span class="n">retopt</span><span class="p">(</span><span class="s1">&#39;tokens&#39;</span><span class="p">):</span>
		<span class="n">ret</span><span class="p">[</span><span class="s1">&#39;tokens&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tokens</span>

	<span class="n">xx</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">output</span><span class="p">)</span> <span class="o">-</span> <span class="n">our_options</span>
	<span class="k">if</span> <span class="n">xx</span><span class="p">:</span>
		<span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Don&#39;t know how to handle output options: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">list</span><span class="p">(</span><span class="n">xx</span><span class="p">))</span>
	<span class="k">return</span> <span class="n">ret</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../index.html">Documentation overview</a><ul>
  <li><a href="../../../index.html">Module code</a><ul>
  <li><a href="../../../scattertext.html">scattertext</a><ul>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Jason S. Kessler.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.7.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
    </div>

    

    
  </body>
</html>